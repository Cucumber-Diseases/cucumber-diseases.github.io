{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This content has a lot of different uses, and it can help with all kinds of different needs and interests. Whether you're an aspiring coder, a Gherkin enthusiast, or a workshop facilitator, we've got you covered. Let's break down the different ways you can leverage this material:</p>"},{"location":"#tutorials-for-the-practice-repositories","title":"Tutorials for the Practice Repositories","text":"<ul> <li>Learn how to set up and work with our repositories. You will find tutorials that guide you through getting started with our repositories and exercises.</li> <li>Goal: Understand the common structure of the repositories.</li> </ul>"},{"location":"#coding-exercises","title":"Coding Exercises","text":"<ul> <li>If you're focused on practicing your coding skills, dive into the provided exercises. These challenges will put your problem-solving abilities to the test.</li> <li>Goal: Strengthen your coding excellence by deliberate exercises.</li> </ul>"},{"location":"#understanding-cucumber-diseases","title":"Understanding Cucumber Diseases","text":"<ul> <li>Delve deeper into the world of Cucumber Diseases by examining the \"smells.\" These are common issues or anti-patterns that can arise when using Gherkin and the programming specific frameworks and tools.</li> <li>Goal: Enhance your understanding of Cucumber best practices and pitfalls.</li> </ul>"},{"location":"#workshop-facilitation","title":"Workshop Facilitation","text":"<ul> <li>Are you planning to lead a workshop or training session? Use this content as a valuable resource for your participants.</li> <li>Goal: Facilitate engaging and informative workshops based on the material provided.</li> </ul> <p>Remember, each section within this content is tailored to address one or more of these goals. Feel free to explore and adapt it according to your specific needs! \ud83c\udf1f</p>"},{"location":"contrib/","title":"Contribution","text":"<p>If you identify additional smells or have suggestions for improvement, feel free to contribute to the repository by opening a pull request or raising an issue.</p> <p>These repositories provide a structured and practical approach to learning about code smells in Gherkin and Cucumber, with the ability to easily switch between smelly code and its solution, giving you a clear understanding of how to improve your test code.</p> <p>You can helop this project by:</p> <ul> <li> Adding a new Smell to the Collection</li> <li> Implementing new Practice Repositories</li> </ul>"},{"location":"contrib/add_repo/","title":"Adding new Practice Repositories","text":"<p>tbd</p>"},{"location":"contrib/add_smell/","title":"Collaboration Approach for Contributing New Smells","text":"<p>When contributing new smells to the <code>cucumber-diseases.github.io</code> repository, follow this collaboration process to ensure the new smells are documented and implemented across language-specific repositories, while minimizing the effort for contributors.</p>"},{"location":"contrib/add_smell/#1-contribute-the-smell-to-the-central-repository","title":"1. Contribute the Smell to the Central Repository","text":"<ul> <li>Create a pull request (PR) in the <code>cucumber-diseases.github.io</code> repository for your new smell.</li> <li>Follow the contribution steps:<ul> <li>Describe the new smell using the smell template.</li> <li>Add a new exercise that addresses the smell, using the exercise template.</li> <li>If necessary, update \"golden master\" feature files to reflect changes in Gherkin syntax.</li> <li>If needed, describe in the PR how to fix the smell in at least one programming language.</li> </ul> </li> </ul>"},{"location":"contrib/add_smell/#2-manually-open-issues-in-language-specific-repositories","title":"2. Manually Open Issues in Language-Specific Repositories","text":"<ul> <li>Once your PR is ready or merged into the documentation repository, manually open issues in all relevant language-specific repositories (e.g., Java, Python, C#, Go).</li> <li>In each issue, include:<ul> <li>A brief description of the smell and how it affects the codebase.</li> <li>A link to the documentation PR that introduces the new smell.</li> <li>Any specific instructions for how the smell and its exercise should be implemented in that language.</li> </ul> </li> </ul>"},{"location":"contrib/add_smell/#3-link-issues-in-your-documentation-pr","title":"3. Link Issues in Your Documentation PR","text":"<ul> <li>In the PR you open for the documentation, include links to the manually created issues in the language-specific repositories.</li> <li>This will ensure visibility across all repositories and help track the adaptation process.</li> </ul> <p>Example:    <pre><code>Linked issues for language repositories:\n- [Java repository issue](https://github.com/cucumber-diseases-java/issues/123)\n- [Python repository issue](https://github.com/cucumber-diseases-python/issues/456)\n</code></pre></p>"},{"location":"contrib/add_smell/#4-cross-repository-labeling-and-tracking","title":"4. Cross-Repository Labeling and Tracking","text":"<ul> <li>In the issues you create, use a consistent label like <code>smell-to-implement</code> to mark new smells requiring adaptation.</li> <li>Optionally, maintain a status dashboard or tracking table in the documentation repository to monitor which smells have been implemented across different language repositories.</li> </ul>"},{"location":"contrib/add_smell/#5-adaptation-by-language-specific-maintainers","title":"5. Adaptation by Language-Specific Maintainers","text":"<ul> <li>Contributors can provide a high-level description of how to address the smell in specific programming languages.</li> <li>However, language-specific maintainers will handle the actual adaptation of the smell and exercise to their respective codebases, ensuring it aligns with the language's conventions and architecture.</li> </ul>"},{"location":"contrib/add_smell/#6-streamlined-collaboration","title":"6. Streamlined Collaboration","text":"<ul> <li>This process ensures contributors focus primarily on documenting new smells and exercises, while language maintainers focus on adapting them.</li> <li>By manually creating issues and linking them in the documentation PR, contributors and maintainers can easily track progress across repositories.</li> </ul>"},{"location":"exercise/","title":"Deliberate Exercises","text":""},{"location":"exercise/#fixing-first-smells","title":"Fixing first smells","text":"<p>Once you've set up the repository and are familiar with the structure, you can begin practicing the identification and refactoring of code smells:</p> <ul> <li>Start with Exploration: Begin by checking out the initial <code>Customer.feature</code> file in the repository. Examine the feature file and associated step definitions to see if you can identify any potential code smells on your own.</li> <li>Use Git Tags for Guided Practice: If you're unsure where to start, use the Git tags to jump directly to known code smells. For example, check out the smell-01 tag to explore the first documented code smell in the repository.</li> <li>Refactor the Smell: Once you've identified a smell, either by your own exploration or by checking out a tagged commit, try refactoring the code to remove the smell. Consider what changes are necessary to improve readability, maintainability, and the overall quality of the test code.</li> <li>Validate Your Solution: After making your changes, compare your refactoring with the solution provided under the corresponding smell-XX-solution tag. This will help you validate your approach and understand any differences.</li> </ul> <p>We generally advise you to start with the first smell \"Missing Then Implementation\" and then gradually work to the next one. The smells presented are usually getting harder to detect and fix the higher you go up in the list. Once you are more accustomed to identifying and refactoring Cucumber smells, you can start checking out different ones in no specific order.</p>"},{"location":"exercise/ex-001-missing-then/","title":"Exercise 001: Implement Missing Then Implementation","text":"<p> Related Smell: 001 - Missing Then Implementation</p>"},{"location":"exercise/ex-001-missing-then/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>Missing Then Step</code> smell.</li> <li>Understand which complications arise from having empty step definitions and how to spot them.</li> </ul>"},{"location":"exercise/ex-001-missing-then/#your-task","title":"Your Task","text":"<p>Within the <code>Customer.feature</code> file there is a <code>Then</code> step that does not do anything. Find at least one such step definition and implement the correct assertion.</p>"},{"location":"exercise/ex-001-missing-then/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>You are looking for empty <code>Then</code> steps.</li> </ul> Hint B <ul> <li>The <code>Then</code> step you are searching for is verifying the creation of a customers.</li> </ul> Hint C <ul> <li>The relevant step is <code>Then the customer creation should be successful</code>.</li> <li>The step definition is an empty function that does not do anything.</li> <li>Think of what it should actually do and implement the correct assertion.</li> </ul> Step by Step Walkthrough <ul> <li>The relevant step is <code>Then the customer creation should be successful</code>.</li> <li>The step definition is an empty function that does not do anything.</li> <li>The function should implement an assertion of the error field.</li> <li>Assert that the error field (e.g. <code>this.error</code> in java or <code>t.err</code> in go) is null.</li> </ul> JavaPythonC#Go <p> GitHub Commit</p> <p> GitHub Commit</p>"},{"location":"exercise/ex-002-unused-given/","title":"Exercise 002: Remove Unused Given Parameter","text":"<p> Related Smell: 002 - Unused Given Parameter</p>"},{"location":"exercise/ex-002-unused-given/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>Unused Given Parameter</code> smell.</li> <li>Understand how to clean it up and how to find all occurances spread over different locations.</li> </ul>"},{"location":"exercise/ex-002-unused-given/#your-task","title":"Your Task","text":"<p>Within the step implementation file there is field, which is intialized by a <code>Given</code>step in the <code>Customer.feature</code>but never used. Find at least one such field and remove the code and the step.</p>"},{"location":"exercise/ex-002-unused-given/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>You are looking for a field in the step implementation, which is set but not read.</li> </ul> Hint B <ul> <li>The relevant field is <code>birthday</code>.</li> <li>Search for all occurances.</li> </ul> Hint C <ul> <li>The relevant field is <code>birthday</code>.</li> <li>The field <code>birthday</code> is only initialized in the step <code>And the customer's birthday is 2000/03/19</code>.</li> <li>Search for other occurances of a date in the code.</li> </ul> Step by Step Walkthrough <ul> <li>The relevant field is <code>birthday</code>.</li> <li>The field <code>birthday</code> is only initialized in the step <code>And the customer's birthday is 2000/03/19</code>.</li> <li>A default birthday is passed to the business function 'Add Customer' in multiple steps.</li> <li>Decide to use the default birthday, since there is no assertion on the correct birthday.</li> <li>Remove the in the step from the step implementation file .</li> <li>Remove the step <code>And the customer's birthday is 2000/03/19</code> in the <code>Customer.feature</code> file.</li> </ul> JavaPythonC#Go <p> GitHub Commit</p> <p> GitHub Commit</p>"},{"location":"exercise/ex-003-data-collector/","title":"Exercise 003: Remove Data Collector","text":"<p> Related Smell: 003 - The Data Collector</p>"},{"location":"exercise/ex-003-data-collector/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>The Data Collector</code> smell.</li> <li>Recognize how multiple <code>Given</code>steps </li> </ul>"},{"location":"exercise/ex-003-data-collector/#your-task","title":"Your Task","text":"<p>Within the <code>Customer.feature</code> file there is a scenario with multiple <code>Given</code> steps, each collecting a part of the data needed in the following <code>When</code> step. Identify the data collector and replace it with a consistent implementation.</p>"},{"location":"exercise/ex-003-data-collector/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>You are looking for multiple <code>Given</code> step with only one parameter.</li> <li>There are two <code>Given</code> steps which need to be called in sequence.</li> </ul> Hint B <ul> <li>The relevant step are <code>Given the customer first name is \"Max\"</code>and <code>And the customer last name is \"Mustermann\"</code>.</li> <li>Look at the implementation in the step definition, how it clutters the scenario and the initialized fields.</li> <li>What happens if you only call one step?</li> <li>Identify an existing consistent expression instead.</li> </ul> Step by Step Walkthrough <ul> <li>The relevant step are <code>Given the customer first name is \"Max\"</code>and <code>And the customer last name is \"Mustermann\"</code>.</li> <li>The consistent way to initialize <code>firstName</code>and <code>lastName</code> is the step <code>Given the customer name is Rose Smith</code></li> <li>Replace the original steps with <code>Given the customer name is Max Mustermann</code></li> <li>Delete the dead step implementations <code>Given the customer first name is \"Max\"</code>and <code>And the customer last name is \"Mustermann\"</code>.</li> </ul> JavaPythonC#Go <p> GitHub Commit</p> <p> GitHub Commit</p>"},{"location":"exercise/ex-004-redundant-mirror-image/","title":"Exercise 004: Refactor Redundant Mirror Image","text":"<p> Related Smell: 004 - Redundant Mirror Image</p>"},{"location":"exercise/ex-004-redundant-mirror-image/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>Redundant Mirror Image</code> smell.</li> <li>Recognize the pattern of duplication even though the expressions are asymmetric.</li> </ul>"},{"location":"exercise/ex-004-redundant-mirror-image/#your-task","title":"Your Task","text":"<p>Within the step implementation are two steps with a similar implemention but an asymmetric expression. Find those steps and merge the expressions.</p>"},{"location":"exercise/ex-004-redundant-mirror-image/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>You are looking for two <code>When</code> steps that are creating a customer with exactly the same implementation.</li> </ul> Hint B <ul> <li>The relevant steps are <code>When the customer is created</code> and <code>When an invalid customer is created</code>.</li> <li>Think about how to merge the code in the step implementation.</li> </ul> Step by Step Walkthrough <ul> <li>The relevant steps are <code>When the customer is created</code> and <code>When an invalid customer is created</code>.</li> <li>Move the expression <code>When an invalid customer is created</code> to the implementation of <code>When the customer is created</code>.</li> <li>Rename the name of the function to something more general.</li> <li>Remove the code of <code>When an invalid customer is created</code>. </li> </ul> JavaPythonC#Go <p> GitHub Commit</p> <p> GitHub Commit</p>"},{"location":"exercise/ex-005-intermediate-when-steps/","title":"Exercise 005: Refactor Intermediate When Steps","text":"<p> Related Smell: 005 - Intermediate When Steps</p>"},{"location":"exercise/ex-005-intermediate-when-steps/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>Intermediate When Steps</code> smell.</li> <li>Learn how to avoid multiple <code>When</code>steps and understand that multiple actions lead to unclear scenarios.</li> </ul>"},{"location":"exercise/ex-005-intermediate-when-steps/#your-task","title":"Your Task","text":"<p>Within the <code>Customer.feature</code> file there are scenerios with multiple <code>When</code> steps. One of those stores an intermediate result to verify it afterwards. Find the <code>When</code>steps and merge them so that the intermediate result is not necessary anymore.</p>"},{"location":"exercise/ex-005-intermediate-when-steps/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>You are looking for a second intermediate <code>When</code> step that is searching for all customers.</li> <li>Make sure you also consider <code>And</code> steps.</li> </ul> Hint B <ul> <li>The relevant step is <code>And all customers are searched</code></li> <li>Look at the implemenation. Why is the <code>When</code>step necessary?</li> </ul> Hint C <ul> <li>The relevant step is <code>And all customers are searched</code></li> <li>The <code>And all customers are searched</code> stores a count, which is checked by the <code>Then</code>step.</li> <li>Check the name of the scenario, how can the existing steps be replaced with a step which expresses the intention more clearly?</li> </ul> Step by Step Walkthrough <ul> <li>The relevant step is <code>And all customers are searched</code></li> <li>The scenario is create a customer and find it afterwords. </li> <li>Searching and counting doesn't clearly express this business need.</li> <li>Instead the <code>Then</code>step should find by name the created customer and check if it matches.</li> <li>Replace <code>And all customers are searched</code> and <code>Then the number of customers found is 1</code> with <code>Then the customer can be found</code></li> </ul> JavaPythonC#Go <p> GitHub Commit</p> <p> GitHub Commit</p>"},{"location":"exercise/ex-006-given-when-purpose-mismatch/","title":"Exercise 006: Refactor Given/When Purpose Mismatch","text":"<p> Related Smell: 006 - Given/When Purpose Mismatch</p>"},{"location":"exercise/ex-006-given-when-purpose-mismatch/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>Given/When Purpose Mismatch</code> smell.</li> <li>Understand the different meaning of the steps <code>Given</code>versus <code>When</code> even the functionality is the same.</li> </ul>"},{"location":"exercise/ex-006-given-when-purpose-mismatch/#your-task","title":"Your Task","text":"<p>Within the <code>Customer.feature</code> file there are multiple occurances of this smell. The exercise is prepared in a way that you only need to refactor steps in the scenarios. Be aware that this is not always the case. Find all scenarios with the smell and replace the <code>When</code> steps with <code>Given</code> instead.</p>"},{"location":"exercise/ex-006-given-when-purpose-mismatch/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>Find all occurances of the smell. You are looking for three scenarios.</li> </ul> Hint B <ul> <li>The first occurance is here: <pre><code>Scenario: Should be able to create two customer with different names\n    Given the customer name is Max Mustermann\n    When the customer is created\n    Given the second customer is Sabine Mustermann\n    When the second customer is created\n    Then the second customer can be found\n</code></pre></li> <li>Identify which <code>When</code> should become a <code>Given</code> step.</li> <li>What's wrong using a <code>When</code> step?</li> </ul> Hint C <ul> <li>The step <code>When the customer is created</code> should be replaced.</li> <li>This <code>When</code> has two purposes: create an customer and focus on the error handling in the code. </li> <li>We only want to verified the creation of the 2nd customer, the 1st is the <code>Given/When Purpose Mismatch</code> smell.</li> <li>Which existing 'Given' step can we you instead?</li> </ul> Step by Step Walkthrough <ul> <li>The step <code>When the customer is created</code> should be replaced.</li> <li>We can use this <code>Given</code> step insted: <pre><code>Given there is a customer\n    | Max | Mustermann |    \n</code></pre> Find the two remaining <code>Given/When Purpose Mismatch</code> smells</li> </ul> Remove all smells <ul> <li>Repeat the previous solution in the scenario <code>Scenario: Cannot create two customer with the same name</code> and <code>Scenario: Should find customers by name</code></li> </ul> Gherkin <p> GitHub Commit</p>"},{"location":"exercise/ex-007-rotting-steps/","title":"Exercise 007: Remove Rotting Steps","text":"<p> Related Smell: 007 - Rotting Steps</p>"},{"location":"exercise/ex-007-rotting-steps/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>Rotting Steps</code> smell.</li> <li>Understand which complications arise from having empty step definitions and how to spot them.</li> </ul>"},{"location":"exercise/ex-007-rotting-steps/#your-task","title":"Your Task","text":"<p>Within the <code>Customer.feature</code> file there is a <code>Given</code> step that is useless. It's describing a precondition in a scenario, which is given anyway. Find the step definition and remove it.</p>"},{"location":"exercise/ex-007-rotting-steps/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>You are looking for an unnecessary <code>Given</code> step in one of the user creation scenarios.  </li> <li>It is added at the begining and it suspicious because the other creation scenarios don't provide it</li> </ul> Hint B <ul> <li>It's the step `Given there are no customers'.</li> <li>The step is called only in the scenario 'Scenario: Should find newly created customer`</li> <li>Look at the implementation of the code in the step definition.</li> </ul> Step by Step Walkthrough <ul> <li>The relevant step is `Given there are no customers'.</li> <li>The step is called only in the scenario 'Scenario: Should find newly created customer`</li> <li>The step definition is an empty function that does not do anything.</li> <li>Remove the step from the scenarion and replace the <code>And</code> in the following step with <code>Given</code>.</li> <li>Delete the step implementation to avoid the <code>Dead Steps</code>smell.</li> </ul> Gherkin <p> GitHub Commit</p>"},{"location":"exercise/ex-008-singular-plural-logic-clones/","title":"Exercise 008: Merge Singular-Plural Logic Clones","text":"<p> Related Smell: 008 - Singular-Plural Logic Clones</p>"},{"location":"exercise/ex-008-singular-plural-logic-clones/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>Singular-Plural Logic Clones</code> smell.</li> <li>Understand what complications arise from merging similar step definitions and how to spot them.</li> </ul>"},{"location":"exercise/ex-008-singular-plural-logic-clones/#your-task","title":"Your Task","text":"<p>Within the step implementation there is a singular and plural expression with a similar implementation. Find  the 2 steps, learn how to merge them and which complications you shoud consider.</p>"},{"location":"exercise/ex-008-singular-plural-logic-clones/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>You are looking two <code>Given</code> steps: first, creation of a single customer and second multiple customers.</li> </ul> Hint B <ul> <li>The relevant steps are <code>Given there is a customer</code> and <code>Given there are some customers</code>.</li> <li>Look at the implementation of the code in the step definition. </li> <li>How can we merge the implementation? What kind of conflicts do we expect?</li> </ul> Step by Step Walkthrough <ul> <li>The relevant steps are <code>Given there is a customer</code> and <code>Given there are some customers</code>.</li> <li>We move the two expression in the code over one implementation i.e. two expression and one function</li> <li>The problem is that the single case doesn't expect a header. So we need to add the header in all scenarios in the <code>Customer.feature</code> file, too.</li> </ul> JavaPythonC#Go <p> GitHub Commit</p> <p> GitHub Commit</p>"},{"location":"exercise/ex-009-dead-steps/","title":"Exercise 009: Remove Dead Steps","text":"<p> Related Smell: 009 - Dead Steps</p>"},{"location":"exercise/ex-009-dead-steps/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>Dead Steps</code> smell.</li> <li>Learn how to search for dead steps and why it's important to remove them asap instead.</li> </ul>"},{"location":"exercise/ex-009-dead-steps/#your-task","title":"Your Task","text":"<p>Within the step implementation there are 3 steps that are not used by the <code>Customer.feature</code>file.  Find and delete them.</p>"},{"location":"exercise/ex-009-dead-steps/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>After solving some exercises and understanding the business, you have maybe an idea which steps are unused.</li> <li>Review the <code>Customer.feature</code>file and then scroll through the step implementation, do you find it?</li> </ul> Hint B <ul> <li>Two steps are empty at all, that means they provide no functionality.</li> <li>The third step implements the negation of finding a customer.</li> </ul> Hint C <ul> <li>The relevant steps are <ul> <li><code>Given no customers exist</code></li> <li><code>When the customer Rose Smith is searched</code></li> <li><code>Then the customer can not be found</code></li> </ul> </li> <li>Brainstorm why this steps are not used anymore</li> </ul> Step by Step Walkthrough <ul> <li>The relevant steps are <ul> <li><code>Given no customers exist</code></li> <li><code>When the customer Rose Smith is searched</code></li> <li><code>Then the customer can not be found</code></li> </ul> </li> <li>Possible explainations:<ul> <li>The step was copied and renamed</li> <li>Somebody didn't find a step and created a similar one</li> <li>It was replaced with parameters or the input data in the scenario was changed</li> <li>Gold plating: implement a step for the future even if currently not used</li> </ul> </li> <li>Remove the implementation from the step definition file.</li> </ul> JavaPythonC#Go <p> GitHub Commit</p> <p>The reqnroll extensions of MS Visual Studio provides a popup menue <code>Find unused Step Definitions</code>. That's the easiest way to solve this smell.</p> <p> GitHub Commit</p>"},{"location":"exercise/ex-010-hardcoded-parameters/","title":"Exercise 010: Replace Hardcoded Parameters","text":"<p> Related Smell: 010 - Hardcoded Parameters</p>"},{"location":"exercise/ex-010-hardcoded-parameters/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>Hardcoded Parameters</code> smell.</li> <li>Understand how hardcoded parameters are introducing duplication and decreasing flexibility in your code.</li> </ul>"},{"location":"exercise/ex-010-hardcoded-parameters/#your-task","title":"Your Task","text":"<p>Within the <code>Customer.feature</code> file there is a <code>When</code> and <code>Then</code> step witn a hardcoded parameter. Find at least one such step definition and implement the correct assertion.</p>"},{"location":"exercise/ex-010-hardcoded-parameters/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>You are looking for steps with hardcoded paramters in the business calls. </li> <li>A hardcoded parameter is expressed in the Gherkin expression.</li> <li>Hardcoded paramters can be of any type. In our exercise you neeed to find two strings.</li> </ul> Hint B <ul> <li>The relevant step is <code>When the customer Sabine Mustermann is searched</code> and <code>Then the customer Sabine Mustermann can be found</code>.</li> <li>Look in the <code>Customer.feature</code> file how it's used. </li> <li>Are there any similar occurrances?</li> <li>What is you next step?</li> </ul> Step by Step Walkthrough <ul> <li>The relevant step is <code>When the customer Sabine Mustermann is searched</code> and <code>Then the customer Sabine Mustermann can be found</code>.</li> <li>We introduce parameters for <code>firstName</code>and <code>secondName</code>. Implement it like in <code>Given the customer name is ...</code>.</li> <li>The step with the expression <code>Then the customer can be found</code> is similar but uses fields instead orf paramters.</li> </ul> JavaPythonC#Go <p> GitHub Commit</p> <p> GitHub Commit</p>"},{"location":"exercise/ex-011-active-sideeffects-in-then-step/","title":"Exercise 011: Refactor Active Side Effects in Then Step","text":"<p> Related Smell: 011 - Active Side Effects in Then Step</p>"},{"location":"exercise/ex-011-active-sideeffects-in-then-step/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>Active Side Effects in Then Step</code> smell.</li> <li>Recognize the misuse when changing an application state in a <code>Then</code>step.</li> </ul>"},{"location":"exercise/ex-011-active-sideeffects-in-then-step/#your-task","title":"Your Task","text":"<p>The step implementation consists two <code>Then</code> steps that changes the data of the system under tests.  Find the <code>Then</code> steps with the smell and move the state change to a fitting <code>When</code> step.</p>"},{"location":"exercise/ex-011-active-sideeffects-in-then-step/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>You are looking for a <code>Then</code> steps that deal with the verification of the second customer.</li> </ul> Hint B <ul> <li>The relevant step are <code>Then the second customer creation should fail</code> and <code>Then the second customer can be found</code>.</li> <li>Look at the implementation of the code in the step definition.</li> <li>Which code is concerning the active side effect?</li> </ul> Hint C <ul> <li>The relevant step are <code>Then the second customer creation should fail</code> and <code>Then the second customer can be found</code>.</li> <li>Both implementations are creating a new customer object!</li> <li>Where does this code belong to?</li> </ul> Step by Step Walkthrough <ul> <li>The relevant step are <code>Then the second customer creation should fail</code> and <code>Then the second customer can be found</code>.</li> <li>Both implementations are creating a new customer object!</li> <li>Remove the creation of the customer object.</li> <li>Create the customer in the step <code>When the second customer is created</code> instead. </li> <li>Implement it similar as in <code>When the customer is created</code>.</li> <li>Should we merge the expressions of <code>When the customer is created</code> and <code>When the second customer is created</code>, or keep it?</li> </ul> JavaPythonC#Go <p> GitHub Commit</p> <p> GitHub Commit</p>"},{"location":"exercise/ex-012-dependence-on-class-state/","title":"Exercise 012: Remove Dependence on Class State","text":"<p> Related Smell: 012 - Dependence on Class State</p>"},{"location":"exercise/ex-012-dependence-on-class-state/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>Dependence on Class State</code> smell.</li> <li>Understand how complexity increases from having shared data on multiple places instead of local parameters.</li> </ul>"},{"location":"exercise/ex-012-dependence-on-class-state/#your-task","title":"Your Task","text":"<p>The step implementation has different fields i.e class state, which can be grouped by system under test, input data and results.  We want to get rid of the input data and replace it with local parameters and variables.</p>"},{"location":"exercise/ex-012-dependence-on-class-state/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>Identify the three groups of class state in your step implementation:<ul> <li>system under test</li> <li>input data</li> <li>results</li> </ul> </li> </ul> Hint B <ul> <li>The input data state is storing information about the customers to be created: first name, last name, ...</li> <li>Remove the first name and last name and analyse the compiler errors.</li> <li>What else can we remove now?</li> </ul> Hint C <ul> <li>Remove the first name and last name.</li> <li>Remove all <code>Given</code>steps in your step implementation and in the <code>Customer.feature</code> file dealing with first name and last name. </li> <li>How can we deal with the missing data in the <code>When</code> and <code>Then</code> steps that instead?</li> </ul> Hint D <ul> <li>Remove the first name and last name.</li> <li>Remove all <code>Given</code>steps in your step implementation and in the <code>Customer.feature</code> file dealing with first name and last name. </li> <li>Add the parameters <code>firstName</code> and <code>lastName</code> to 'When the customer is created'. </li> <li>Remove <code>Then the customer can be found</code> because there is already a expression with the parameters.</li> <li>Change the <code>Customer.feature</code> file accordingly and pass the parameters via the steps.</li> <li>Which class state can be remove now?</li> </ul> Step by Step Walkthrough <ul> <li>Remove the first name and last name.</li> <li>Remove all <code>Given</code>steps in your step implementation and in the <code>Customer.feature</code> file dealing with first name and last name. </li> <li>Add the parameters <code>firstName</code> and <code>lastName</code> to 'When the customer is created'. </li> <li>Remove <code>Then the customer can be found</code> because there is already a expression with the parameters.</li> <li>Change the <code>Customer.feature</code> file accordingly and pass the parameters via the steps.</li> <li>Remove the state for handling a second customer in the same way as previously the first name and last name.</li> <li>Pass parameters to the expression for the second customer. </li> <li>Merge the expression and delete the unnecessary functions for example: 'Then the customer {} {} can be found'  and 'Then the second customer {} {} can be found' </li> </ul> JavaPythonC#Go <p> GitHub Commit</p> <p> GitHub Commit</p>"},{"location":"exercise/ex-013-test-code-impurity/","title":"Exercise 013: Refactor Test Code Impurity","text":"<p> Related Smell: 013 - Test Code Impurity</p>"},{"location":"exercise/ex-013-test-code-impurity/#purpose","title":"Purpose","text":"<ul> <li>Learn to identify the <code>Test Code Impurity</code> smell.</li> <li>See how this smell differs from the other smells and how complicated the refactoring is about, if there is already a lot of test automation code available.</li> </ul>"},{"location":"exercise/ex-013-test-code-impurity/#your-task","title":"Your Task","text":"<p>We will only change the step implementation file. Create a new file and add a driver implementation. Move all calls to the system under test to the driver class.</p>"},{"location":"exercise/ex-013-test-code-impurity/#solution","title":"Solution","text":"HintsDiffs Hint A <ul> <li>How can we split the refactoring to reduce the risk?</li> </ul> Hint B <ul> <li>We have steps that deal with the creation and steps that provide the search business logic.</li> <li>Which is the simplest first refactoring?</li> </ul> Hint C <ul> <li>The simplest refactoring is moving the code from the step <code>Given there is a customer</code> and <code>Given there are some customers</code> to a driver class.</li> <li>Why is this so simple?</li> </ul> Hint D <ul> <li>The simplest refactoring is moving the code from the step <code>Given there is a customer</code> and <code>Given there are some customers</code> to a driver class.</li> <li>It handles only the <code>Given</code> steps to create customers in the system under test and it doesn't deal with state in the test implementation.</li> <li>We can create the new class and inject the driver into the step implementation.</li> <li>Then create a new method and move the code into it. Replace the code with a call to the driver instead.</li> <li>How to continue?</li> </ul> Step by Step Walkthrough <ul> <li>The simplest refactoring is moving the code from the step <code>Given there is a customer</code> and <code>Given there are some customers</code> to a driver class.</li> <li>It handles only the <code>Given</code> steps to create customers in the system under test and it doesn't deal with state in the test implementation.</li> <li>We can create the new class and inject the driver into the step implementation.</li> <li>Then create a new method and move the code into it. Replace the code with a call to the driver instead.</li> <li>Next we continue with the customer creation in the <code>When</code>steps. </li> <li>Start with a public <code>error</code> field in the driver and access it in the step implementation.</li> <li>Then encapsulate the <code>error</code> with a method to check if the creation failed or was successful.</li> <li>Next move the search business logic to the driver class.</li> <li>Finally cleanup your step implementation. You get rid of the system under test and all fields dealing with results. There is only a reference to the driver class.</li> </ul> JavaPythonC#Go <p> GitHub Commit</p> <p> GitHub Commit</p>"},{"location":"intro/contributors/","title":"Contributors","text":"<p>This project was initiated by Roland Germ. It is currently maintained by</p> <ul> <li>Roland Germ (@rolger)</li> <li>Daniel Eder (@lycis)</li> </ul> <p>Special thanks goes to the many people who helped to shape the smells and code, as well as to all those people who helped to improve it through participating in our workshops. Among these we want to specially name:</p> <ul> <li>Stefan Gwihs (@sgwihs)</li> <li>Thomas Goldberger</li> <li>Katrin Heiderer (@heidererkatrin)</li> </ul> <p>You want to contribute as well? Take a look at the Contribution section.</p>"},{"location":"repos/","title":"Practice Repositories","text":"<p>To help users learn about and practice identifying and removing code smells in Gherkin and Cucumber, we have set up a series of practice repositories. Each repository is dedicated to a specific programming language and offers a hands-on environment where you can work with feature files and Gherkin scenarios, along with step implementations and frameworks like Cucumber for Java or equivalent tools for other languages. These repositories allow you to explore various code smells, understand their impact, and practice refactoring to remove them.</p>"},{"location":"repos/#available-repositories","title":"Available Repositories","text":"<p>The practice repositories are hosted on GitHub under the Cucumber-Diseases organization. The repositories are as follows:</p> <ul> <li> <code>cucumber-diseases-java</code></li> <li> <code>cucumber-diseases-python</code></li> <li> <code>cucumber-diseases-go</code></li> <li>C# <code>cucumber-diseases-csharp</code></li> </ul> <p>Each repository implements the same basic and simple application, using the <code>Customer.feature</code> file as a starting point. This consistent baseline allows you to compare and contrast the different smells and their resolutions across languages.</p>"},{"location":"repos/#cloning-the-repository","title":"Cloning the Repository","text":"<p>To start practicing, clone the repository for the language you are interested in:</p> <pre><code>git clone https://github.com/Cucumber-Diseases/cucumber-diseases-&lt;language&gt;.git\n</code></pre> <p>Replace <code>&lt;language&gt;</code> with the programming language of your choice, such as <code>java</code>, <code>python</code>, <code>go</code>, or <code>csharp</code>.</p>"},{"location":"repos/#repository-structure","title":"Repository Structure","text":"<p>Each repository contains:</p> <ul> <li>Starting Point: The 'main' branch serves as the starting point for your refactoring journey. Check it out and get started!</li> <li>Step By Step Solution: Each repository includes a second branch called step-by-step, which contains a complete commit history of fixes for the various code smells.</li> <li>Feature Files: Starting with <code>Customer.feature</code>, where you can observe and practice identifying Gherkin and Cucumber-related code smells.</li> <li>Tags for Smells: The commit history includes Git tags that correspond to specific code smells, allowing you to jump to a state where a particular smell is present.</li> <li>Source Code of the Example Service i.e. System Under Test: Each repository contains a very slim implementation of a service that will be tested. It is simple and easy on purpose to not destract from the testing code.</li> <li>Test Step Implementation: The test suite is set up in a way that it works from the start. It should run all tests green directly after cloning and contains all relevant step definitions for the Gherkin feature file included.</li> </ul>"},{"location":"repos/#setting-up-the-project","title":"Setting Up the Project","text":"<p>After checking out a specific state of the repository, refer to the README file for instructions on setting up the project in your local environment. This includes installing dependencies, running tests, and other language-specific setup steps.</p> <p>Usually all repositories are set up in a way that, after initially getting the dependencies, you can easily run the feature tests with a simple command. Refer to the subpages here that give you additional guidance and step by step instructions how to get each repository running as well as the particularities of each project.</p>"},{"location":"repos/#using-git-tags-to-explore-smells","title":"Using Git Tags to Explore Smells","text":"<p>The repositories utilize Git tags to help you navigate through different states of the codebase, each representing a specific code smell and its resolution. The tags follow a consistent naming convention:</p> <ul> <li><code>smell-XX</code>: A tag that marks the state of the codebase where a specific code smell (<code>XX</code> corresponds to the smell ID) is present.</li> <li><code>smell-XX-solution</code>: A tag that marks the state of the codebase after the smell has been removed.</li> </ul> <p>To explore a specific code smell:</p>"},{"location":"repos/#checkout-the-smell","title":"Checkout the Smell","text":"<p>To view the codebase with a particular smell, use the following command:</p> <pre><code>git checkout tags/smell-XX\n</code></pre> <p>Replace <code>XX</code> with the specific smell ID you want to explore.</p>"},{"location":"repos/#compare-with-the-solution","title":"Compare with the Solution","text":"<p>To see the changes required to remove the smell, you can use Git's diff command to compare the <code>smell-XX</code> tag with its corresponding <code>smell-XX-solution</code> tag:</p> <pre><code>git diff smell-XX smell-XX-solution\n</code></pre> <p>This will show you the differences between the smelly code and the refactored solution, helping you understand how to address the issue.</p>"},{"location":"repos/csharp/","title":"C#","text":""},{"location":"repos/example_application/","title":"Example application","text":""},{"location":"repos/example_application/#the-reference-application","title":"The Reference Application","text":"<p>todo: describe the architecture and functionality of the reference application implemented in the practice repositories</p>"},{"location":"repos/go/","title":"Golang","text":""},{"location":"repos/java/","title":"Java","text":""},{"location":"repos/python/","title":"Python","text":""},{"location":"smells/","title":"Overview","text":"<p>In this section we list all the Cucumber/Gherkin/BDD smells we catelogued. Navigate to any specific diseases to learn about the details!</p>"},{"location":"smells/#what-are-code-smells","title":"What are code smells?","text":"<p>The term code smell was originally mentioned by Kent Beck as explained by Martin Fowler\u2019s description of code smells.</p> <p>\"A code smell is a surface indication that usually corresponds to a deeper problem in the system.\" </p> <p>Kent Beck, Martin Fowler</p> <p>While a code smell doesn't necessarily mean the code is incorrect or non-functional, it suggests that the code may be poorly designed, difficult to maintain, or prone to bugs. Code smells often point to deeper issues in the codebase that could lead to more significant problems if not addressed.</p> <p>There are several lists of code smells available online. One of the most well-known is found in Martin Fowler\u2019s book Refactoring. Additionally, you can explore other widely recognized lists on platforms such as Wikipedia, Coding Horror and Refactoring Guru. These resources provide comprehensive overviews of common code smells and offer insights into best practices for identifying and addressing them.</p>"},{"location":"smells/#description-of-smells","title":"Description of Smells","text":"<p>All Cucumber smells are described in the same layout to make it easier for you to navigate. The all</p> <ul> <li>Start with a description of the smell</li> <li>Impact: Describe the impact if present in your tests</li> <li>Required Action: Tell you what you need to do and lists different alternative solutions in order to remove them.</li> <li>Code Samples: Examples in some programming languages to show you how it looks in the wild.</li> </ul>"},{"location":"smells/#rating-of-impacts","title":"Rating of Impacts","text":"<p>In order to make it easier for you to understand the severity of the impacts described in the smells, there is a simple rating system in place:</p> <ul> <li> <p>Makes your tests useless. It is a bug. Remove immediately.</p> </li> <li> <p>Introduces a grave problem that will screw up in the near future. Get rid of it asap!</p> </li> <li> <p>This is a problem. It will not bite you immediately, but increases technical debt drastically. Future maintenance is impacted.</p> </li> <li> <p>It is a concern. You can live with it for some time, but it will bite your back in a couple of months.</p> </li> </ul> <p>Regardless of the rating, all the impacts described are a problem. The whole purpose of this list is to educate you how to prevent them. So, there's no arguing about getting even rid of concerns. We would not talk about it, if it would not be relevant.</p>"},{"location":"smells/#list-of-all-smells","title":"List of all Smells","text":"ID# Name Short Description 001 Missing 'Then' Implementation Gherkin scenarios lack \"Then\" steps (assertions). 002 Unused 'Given' Parameter Parameters initialized in \"Given\" steps but never used. 003 Data Collector Setting data incrementally across multiple \"Given\" steps. 004 Redundant Mirror Image Duplicate steps with asymmetric expressions but same logic. 005 Intermediate When Steps Violation of the fundamental principle of Behavior-Driven Development (BDD): One Scenario, One Behavior! 006 Given/When Purpose Mismatch Misuse of Given/When steps 007 Rotting Steps Irrelevant steps cluttering scenarios. 008 Singular-Plural Logic Clones Duplicated steps for singular/plural cases. 009 Dead Steps Step definitions exist but are not used. 010 Hardcoded Parameters Using fixed values instead of parameters. 011 Active Side Effects in Then Step Changes of the application state in \"Then\" steps. 012 Dependence on Class State Excessive reliance on context or class state. 013 Test Code Impurity Mixing different test automation concerns in step definitions."},{"location":"smells/001-missing-then/","title":"001: Missing Then Implementation","text":"<p>This smell refers to steps within your Gherkin scenarios that lack assertions (specifically, <code>Then</code> steps). When you encounter a step without an assertion, it means that the scenario doesn\u2019t verify any expected outcome or behavior. Essentially, it\u2019s like having a test case without an assertion in your test suite.</p>"},{"location":"smells/001-missing-then/#impact","title":"Impact","text":"<p>Missing System Validation</p> <p>Without assertions, your scenarios may not effectively validate the system\u2019s behavior.</p> <p>Makes BDD Irrelevant</p> <p>It undermines the purpose of behavior-driven development (BDD) because the scenarios don\u2019t provide meaningful feedback.</p> <p>False-Negatives</p> <p>Unverified steps can lead to false negatives (where a scenario passes even if it shouldn\u2019t).</p>"},{"location":"smells/001-missing-then/#required-action","title":"Required Action","text":"<p>Identify all steps within your Gherkin scenarios that lack assertions. Then, choose one of these steps to implement the missing assertion.</p> <p>Decide which criteria apply and select the step depending on your answers:</p> <ul> <li>Simplicity: Selected for a straightforward  step</li> <li>Relevance: Ensure that the selected step makes sense in your scenarios</li> <li>No Further Improvement Needed: Confirm that there\u2019s no additional enhancement required for the chosen step. *Reverse Implementation: Check if there\u2019s another <code>Then</code> step that expresses the opposite behavior</li> </ul>"},{"location":"smells/001-missing-then/#code-examples","title":"Code Examples","text":"JavaPythonC#Go CustomerStepDefinitons.java<pre><code>@Then(\"the customer creation should be successful\")\npublic void theCustomerCreationShouldBeSuccessful() {\n   //(1)!\n}\n</code></pre> <ol> <li>Note that the step <code>Then the customer creation should be successful</code> contains no code. It should contain a <code>assert</code>-Statement.</li> </ol> features/steps/steps.py<pre><code>@then(u'the customer creation should be successful')\ndef step_impl(context):\n    pass #(1)!\n</code></pre> <ol> <li>Note that the step <code>Then the customer creation should be successful</code> contains no code. It should contain a <code>assert</code>-Statement.</li> </ol> StepDefinitions/CustomerStepDefinitions.cs<pre><code>[Then(\"the customer creation should be successful\")]\npublic void ThenTheCustomerCreationShouldBeSuccessful()\n{\n    //(1)!\n}\n</code></pre> <ol> <li>Note that the step <code>Then the customer creation should be successful</code> contains no code. It should contain a <code>assert</code>-Statement.</li> </ol> <pre><code>func (t *CustomerTestSteps) theCustomerCreationShouldBeSuccessful(ctx context.Context) error {\n    return nil //(1)!\n}\n// ...\n\nfunc InitializeScenario(sc *godog.ScenarioContext) {\n// ...\n\nsc.Then(`the customer creation should be successful`, t.theCustomerCreationShouldBeSuccessful)\n\n// ...\n}\n</code></pre> <ol> <li>Note that the step <code>Then the customer creation should be successful</code> contains no code. It should contain an assertion.</li> </ol>"},{"location":"smells/002-unused-given/","title":"002: Unused Given Parameter","text":"<p>This code smell occurs when a field or property is initialized within a <code>Given</code> step but remains unused throughout the scenario. Essentially, it\u2019s like setting up a variable or resource but never actually utilizing it in subsequent steps.</p> <p>Possible reasons include:</p> <ul> <li>Redundancy: The parameter duplicates information already available elsewhere.</li> <li>Obsolete Logic: The parameter was relevant in an earlier version of the scenario but is no longer necessary.</li> <li>Incomplete Implementation: The parameter was added but not fully integrated into the scenario.</li> </ul>"},{"location":"smells/002-unused-given/#impact","title":"Impact","text":"<p>Misleading Code</p> <p>They can mislead readers into thinking that the parameter plays a crucial role in the scenario.</p> <p>Harder Maintenance</p> <p>Maintenance becomes harder as unused parameters accumulate over time.</p> <p>Increased Complexity</p> <p>Unused parameters clutter the scenario and add unnecessary complexity.</p>"},{"location":"smells/002-unused-given/#required-action","title":"Required Action","text":"<p>Search your code for any field/property which is initialized by a step but never used afterwards. Find these fields, analyze why it is not used and decide either to remove it or to use it: </p> <ul> <li>Remove It: If the parameter serves no purpose, eliminate it.</li> <li>Use It: If the parameter has a valid role, ensure it\u2019s utilized appropriately.</li> </ul>"},{"location":"smells/002-unused-given/#code-examples","title":"Code Examples","text":""},{"location":"smells/002-unused-given/#gherkin","title":"Gherkin","text":"Customer.feature<pre><code>Scenario: Should successfully create new customer\n    Given the customer first name is \"Max\"\n    And the customer last name is \"Mustermann\"\n    And the customer's birthday is 2000/03/19\n# (1)!\n    When the customer is created\n    Then the customer creation should be successful\n</code></pre> <ol> <li>Mind that <code>birthday</code> is set but not checked in the <code>Then</code> steps. The <code>birthday</code> is also not evaluated in any hidden assertions within the <code>Then the customer creation should be successful</code> step.</li> </ol>"},{"location":"smells/003-data-collector/","title":"003: The Data Collector","text":"<p>The \u201cData Collector\u201d code smell occurs within your \u201cGiven\u201d steps in Gherkin scenarios. It\u2019s related to the use of the Builder pattern, where you set the values of fields incrementally across multiple steps. By passing data piece by piece, this pattern leads to long scripts with individual steps for each field.</p>"},{"location":"smells/003-data-collector/#impact","title":"Impact","text":"<p>Harder Maintenance</p> <p>Any change to the domain object requires updating multiple steps.</p> <p>Increased Complexity</p> <p>Readers must follow a sequence of steps to understand the complete data setup.</p> <p>Increased Coupling</p> <p>The coupling between scenarios and step implementation increases, especially when the order of steps matters. Changes in one step may ripple through others, affecting the entire scenario.</p> <p>Inconsistent Data</p> <p>The user of the scenarion must not omit any mandatory <code>Given</code> steps. If all required steps are not executed, it may result in inconsistent or uninitialized data.</p> <p>Increased Script Length</p> <p>The scenario becomes verbose due to numerous steps dedicated to setting field values.</p>"},{"location":"smells/003-data-collector/#required-action","title":"Required Action","text":"<p>Replace multiple <code>Given</code> steps with a single step that passes the entire data object (from the same domain) at once. If required introduce a new step that initializes a domain object with all parameters required in a single step.</p>"},{"location":"smells/003-data-collector/#code-examples","title":"Code Examples","text":""},{"location":"smells/003-data-collector/#gherkin","title":"Gherkin","text":"Customer.feature<pre><code>Scenario: Should successfully create new customer\n    Given the customer first name is \"Max\"\n    And the customer last name is \"Mustermann\"\n# (1)!\n    When the customer is created\n    Then the customer creation should be successful\n</code></pre> <ol> <li>The data for a customer is collected in two different steps. Merge the steps to pass the data at once instead.</li> </ol>"},{"location":"smells/004-redundant-mirror-image/","title":"004: Redundant Mirror Image","text":"<p>The \u201cRedundant Mirror Image\u201d code smell involves code duplication within your Gherkin scenarios. When the same implementation logic appears multiple times with different expressions, consider consolidating it into reusable expressions. Even if the expressions seem completely mismatched (representing opposite behaviors, such as success and failure cases), both scenarios verify the same behavior.</p>"},{"location":"smells/004-redundant-mirror-image/#impact","title":"Impact","text":"<p>Test Inconsistency</p> <p>If one side of the mirror image is updated without considering the other, scenarios may become inconsistent.</p> <p>Harder Maintenance</p> <p>Any change to one step affects all implementations.</p>"},{"location":"smells/004-redundant-mirror-image/#required-action","title":"Required Action","text":"<p>Identify steps that share the same implementation but describe asymmetric behavior.  If you find such steps, consider consolidating them by using multiple expressions for a single implementation.</p>"},{"location":"smells/004-redundant-mirror-image/#code-examples","title":"Code Examples","text":"JavaPythonC#Go CustomerStepDefinitions.java<pre><code>@When(\"the customer is created\") // (1)!\npublic void theCustomerIsCreated() {\n    try {\n        customerService.addCustomer(firstName, lastName, DEFAULT_BIRTHDAY);\n    } catch (IllegalArgumentException e) {\n        error = e;\n    }\n}\n\n@When(\"an invalid customer is created\")\npublic void anInvalidCustomerIsCreated() {\n    try {\n        customerService.addCustomer(firstName, lastName, DEFAULT_BIRTHDAY);\n    } catch (IllegalArgumentException e) {\n        error = e;\n    }\n}\n</code></pre> <ol> <li><code>anInvalidCustomerIsCreated</code> contains the same implementation as <code>theCustomerIsCreated</code>. It is the logical opposite, but does the same thing, just that we expect it to throw an <code>IllegalArgumentException</code> in one case and have <code>error</code> be <code>null</code> in the other. The only real difference comes from the subsequent <code>Then</code> step that makes a distinction in the verification.</li> </ol> features/steps/steps.py<pre><code>when(u'the customer is created') # (1)!\ndef step_impl(context):\n    try:\n        context.service.add_customer(context.first_name, context.last_name, context.default_birthday)\n    except ValueError as e:\n        context.error = e\n\n@when(u'an invalid customer is created')\ndef step_impl(context):\n    try:\n        context.service.add_customer(context.first_name, context.last_name, context.default_birthday)\n    except ValueError as e:\n        context.error = e\n</code></pre> <ol> <li><code>the customer is created</code> contains the same implementation as <code>an invalid customer is created</code>. It is the logical opposite, but does the same thing, just that we expect it to throw a <code>ValueError</code> in one case and have <code>context.error</code> be <code>None</code> in the other. The only real difference comes from the subsequent <code>Then</code> step that makes a distinction in the verification.</li> </ol> CustomerStepDefinitions.cs<pre><code>[When(\"the customer is created\")]\npublic void WhenTheCustomerIsCreated() // (1)!\n{\n    try\n    {\n        _customerService.AddCustomer(_firstName, _lastName, DefaultBirthday);\n    }\n    catch (ArgumentException ex)\n    {\n        _error = ex;\n    }\n}\n\n[When(\"an invalid customer is created\")]\npublic void WhenAnInvalidCustomerIsCreated()\n{\n    try\n    {\n        _customerService.AddCustomer(_firstName, _lastName, DefaultBirthday);\n    }\n    catch (ArgumentException ex)\n    {\n        _error = ex;\n    }\n}\n</code></pre> <ol> <li><code>WhenAnInvalidCustomerIsCreated</code> contains the same implementation as <code>WhenTheCustomerIsCreated</code>. It is the logical opposite, but does the same thing, just that we expect it to throw a <code>ArgumentException</code> in one case and have <code>_error</code> be <code>None</code> in the other. The only real difference comes from the subsequent <code>Then</code> step that makes a distinction in the verification.</li> </ol> customer_test.go<pre><code>func (t *CustomerTestSteps) theCustomerCreationShouldBeSuccessful(ctx context.Context) error {\n    // ...\n    sc.When(`^the customer is created$`, t.theCustomerIsCreated)\n    sc.When(`an invalid customer is created`, t.anInvalidCustomerIsCreated) // (1)!\n    // ...\n}\n\nfunc (t *CustomerTestSteps) anInvalidCustomerIsCreated(ctx context.Context) error {\n    t.err = t.customerService.AddCustomer(t.firstName, t.lastName, DEFAULT_BIRTHDAY)\n    return nil\n}\n\nfunc (t *CustomerTestSteps) theCustomerIsCreated(ctx context.Context) error {\n    t.err = t.customerService.AddCustomer(t.firstName, t.lastName, DEFAULT_BIRTHDAY)\n    return nil\n}\n</code></pre> <ol> <li><code>anInvalidCustomerIsCreated</code> contains the same implementation as <code>theCustomerIsCreated</code>. It is the logical opposite, but does the same thing, just that we expect it to set an error instead of returnung <code>nil</code> for an error. The only real difference comes from the subsequent <code>Then</code> step that makes a distinction in the verification.</li> </ol>"},{"location":"smells/005-intermediate-when-steps/","title":"005: Intermediate When Steps","text":"<p>The Intermediate When Steps (also called \"When/Then Mismatch) code smell violates the fundamental principle of Behavior-Driven Development (BDD): One Scenario, One Behavior!</p> <p>When a scenario contains multiple <code>When</code> steps, it indicates an issue within the scope or the purpose of your test case. Are you using \"Intermediate When Steps\" to store multiple results? This leads to unclear and suspicious assertions in the <code>Then</code> step.</p> <p>If you encounter this smell, the <code>When</code> step is misused in order to execute or prepare a functionality that is not directly under test by the scenario for it's side effects. Very often this is to prepare some condition required by the verification in the following <code>Then</code> steps.</p> <p>It is very strongly related to Given/When Purpose Mismatch. The significant difference is that this smell executes an action that is relevant for the <code>Then</code> step while the \"Given/When Purpose Mismatch\" executes something as a <code>When</code> as preparation for another <code>When</code> step step that should be part of a <code>Given</code> step.</p>"},{"location":"smells/005-intermediate-when-steps/#impact","title":"Impact:","text":"<p>Reduced Clarity</p> <p>Combining behaviors into a single scenario leads to ambiguity and miscommunication.</p> <p>Harder Analysis</p> <p>When a test fails, identifying the root cause becomes challenging because it could be related to any of the multiple behaviors.</p> <p>Duplication</p> <p>Scenarios that repeat the same sequence of steps instead of isolating behaviors risk unnecessary duplication.</p>"},{"location":"smells/005-intermediate-when-steps/#required-action","title":"Required Action","text":"<p>Look for scenarios that have more than one <code>When</code> (or <code>When ... And ...</code>) steps and inspect them for what they are trying to achieve. There are three common ways to resolve this situation:</p> <ol> <li>Merge Steps: In the case of multiple \"When\" steps the most obvious solution could be merging the implementation into something new. Consider also merging or replacing multiple \"When\" steps with a  \"Then\" step. This happens if you storing multiple results or there is something suspicious in your assertion.</li> <li>Rearrange Steps: This is similar to merging steps. Ask your self, which steps are describing the action and which of them are preparing or asserting the scenarios.</li> <li>Isolate Behaviors: Create separate scenarios for each distinct behavior.</li> </ol>"},{"location":"smells/005-intermediate-when-steps/#code-examples","title":"Code Examples","text":""},{"location":"smells/005-intermediate-when-steps/#gherkin","title":"Gherkin","text":"Customer.feature<pre><code>Scenario: Should find newly created customer\n    Given the customer name is Rose Smith\n    When the customer is created\n    And all customers are searched\n# (1)!\n    Then the number of customers found is 1\n</code></pre> <ol> <li>Note the <code>When ... And ...</code> composition of the scenario. In this case the author is misusing <code>And all customers are searched</code> as a <code>When</code> clause, even though it is not the functionality under test. Instead, searching all customers is part of the verification and assertion of the <code>Then</code> step. A viable solution would be to introduce a <code>Then</code> step that represents <code>search and check the returned number of customers</code>.</li> </ol>"},{"location":"smells/006-given-when-purpose-mismatch/","title":"006: Given/When Purpose Mismatch","text":"<p>The Given/When Purpose Mismatch occurs when the roles of <code>Given</code> and <code>When</code> steps are confused or misused in a Gherkin scenario. It happens when the Given step is intended to set up test data, while the <code>When</code> step is meant to test a function that creates something. In a proper setup (<code>Given</code>), the focus should be on preparing the necessary context or state, without concern for validation or correctness. However, the implementation of these steps may be similar or identical, leading to confusion.</p>"},{"location":"smells/006-given-when-purpose-mismatch/#impact","title":"Impact","text":"<p>Harder Maintenance</p> <p>Maintaining such tests becomes challenging, as the conflation of setup and behavior testing can lead to brittle tests that are difficult to update or refactor.</p> <p>Unreadable Code</p> <p>Scenarios become harder to understand because the purpose of each step is unclear, leading to confusion about what is being tested.</p> <p>Reduced Clarity</p> <p>The distinction between preparation and verification blurs, making it difficult to discern whether the scenario is setting up context or validating functionality.</p> <p>Increased Complexity</p> <p>This smell can increase the complexity of tests, as it introduces unnecessary checks and validations in the setup phase, complicating the logic of the test steps.</p>"},{"location":"smells/006-given-when-purpose-mismatch/#required-action","title":"Required Action","text":"<p>When you identify a <code>Given/When Purpose Mismatch</code> in the scenarios, there are multiple ways to resolve them:</p> <ol> <li>Separate Concerns: Clearly differentiate between <code>Given</code> and <code>When</code> steps. Ensure that Given steps are solely for setting up the context without any assertions, and <code>When</code> steps are used to trigger the behavior you want to test, including necessary validations.</li> <li>Refactor Steps: If you identify a <code>Given</code> step that performs validation or verification, refactor it into a <code>When</code> step to align with the intended purpose. Similarly, ensure that <code>When</code> steps do not involve unnecessary setup.</li> <li>Use Scenario Outlines: If multiple scenarios share similar setups, use scenario outlines to parameterize the Given step and avoid code duplication.</li> <li>Use Data Tables: If your scenario needs different test data of the same kind pass a data tale instead of duplicating your <code>Given</code> steps.</li> </ol> <p>Depending on the exact situation different actions may be appropriate.</p>"},{"location":"smells/006-given-when-purpose-mismatch/#code-examples","title":"Code Examples","text":""},{"location":"smells/006-given-when-purpose-mismatch/#gherkin","title":"Gherkin","text":"Customer.feature<pre><code>Scenario: Should be able to create two customer with different names\n   Given the customer name is Max Mustermann\n   Given the second customer is Sabine Mustermann\n   When the customer is created\n# (1)!\n   When the second customer is created\n   Then the second customer can be found\n</code></pre> <ol> <li>In this case the creation of the first customer is only executed as a <code>When</code> step in order to then execute the creation of the second customer. The actual behaviour under test is the creation of the second customer. A possible solution here would be to create a <code>Then</code> step that includes the creation of the first customer.</li> </ol>"},{"location":"smells/007-rotting-steps/","title":"007: Rotting Steps","text":"<p>\u201cRotting Steps\u201d refer to Gherkin steps within a scenario that lack meaningful purpose or relevance. These steps may have empty implementations or contribute nothing substantial to the scenario. They often appear in <code>Given</code> steps, where they set up initial conditions but fail to add value.</p>"},{"location":"smells/007-rotting-steps/#impact","title":"Impact","text":"<p>Misleading Code</p> <p>Readers may assume these steps play a crucial role when they don\u2019t.</p> <p>Harder Maintenance</p> <p>Empty or irrelevant steps require unnecessary upkeep.</p> <p>Scenario Clutter</p> <p>Unnecessary steps make scenarios harder to read and understand.</p>"},{"location":"smells/007-rotting-steps/#required-action","title":"Required Action","text":"<p>Eliminate steps that don\u2019t contribute to the behavior being tested. Indicators are:</p> <ul> <li><code>Given</code> step used only once and implicitly setup,</li> <li><code>Given</code> steps covered already by a <code>Background</code> step or scenario initialisation (e.g. default starting conditions)</li> <li>Empty implementations</li> </ul>"},{"location":"smells/007-rotting-steps/#code-examples","title":"Code Examples","text":""},{"location":"smells/007-rotting-steps/#gherkin","title":"Gherkin","text":"Customer.feature<pre><code>Scenario: Should find newly created customer\n    Given there are no customers\n# (1)!\n    And the customer name is Rose Smith\n    When the customer is created\n    Then the customer can be found\n</code></pre> <ol> <li>The step <code>Given there are no customers</code> does not add any value as this is the default condition for a scenario. It is verbose expressiveness without adding function or value to the step.</li> </ol>"},{"location":"smells/008-singular-plural-logic-clones/","title":"008: Singular-Plural Logic Clones","text":"<p>This code smell occurs when there are multiple, nearly identical implementations of step definitions to handle singular and plural cases. These implementations often share similar logic but differ only in the handling of singular and plural nouns. The underlying idea is akin to the \u201cDon\u2019t Repeat Yourself\u201d (DRY) principle, which encourages code reuse and consolidation.</p>"},{"location":"smells/008-singular-plural-logic-clones/#impact","title":"Impact","text":"<p>Test Inconsistency</p> <p>Inconsistent parameter handling syntax can lead to errors and inconsistencies.</p> <p>Unreadable Code</p> <p>The code becomes less readable and harder to understand due to the duplication.</p> <p>Harder Maintainability</p> <p>Changes to the underlying logic must be applied to multiple step definitions, increasing maintenance effort.</p> <p>Increased Complexity</p> <p>The codebase becomes more complex and harder to manage with redundant implementations.</p>"},{"location":"smells/008-singular-plural-logic-clones/#required-action","title":"Required Action","text":"<p>When you identify a <code>Singular-Plural Logic Clones</code> in your scenario, there are multiple ways to resolve them:</p> <ul> <li>Combine Step Definitions: Merge the singular and plural step definitions into a single definition with multiple expressions and using parameterization to handle variations.</li> <li>Use Regular Expressions / Leverage Parameter Handling: Consider using regular expressions or custom parameter types to handle dynamic values effectively.</li> <li>Ensure Consistent Syntax: Standardize the parameter handling syntax across all step definitions to improve readability and maintainability.</li> </ul>"},{"location":"smells/008-singular-plural-logic-clones/#code-examples","title":"Code Examples","text":"<p>To understand this smell, please refer to the Gherkin code as well as the code in the implementation in one of the programming languages. It makes the most sense if the scenarios and the implementation are both read together.</p>"},{"location":"smells/008-singular-plural-logic-clones/#gherkin","title":"Gherkin","text":"Customer.feature<pre><code># (1)!\nScenario: Should find an existing customer\n    Given there is a customer \n        | Sabine | Mustermann |\n    Then the customer Sabine Mustermann can be found\n\n# ...\n\nScenario: Should find multiple customers\n    Given there are some customers # (1)\n        | firstname | lastname   |\n        | Max       | Mustermann |\n        | Sabine    | Mustermann |\n        | Horst     | Mustermann |\n    When all customers are searched\n    Then the number of customers found is 3\n</code></pre> <ol> <li>The steps <code>Given there is a customer</code> and <code>Given there are some customers</code> are in different scenarios, but essentially have the same meaning. The only difference is that one gives the precondition of having a singular customer with a given name and the other provides multiple customers based on a list of given names. While linguistically different, the implementation of both steps should refer to the same, more generic, step implementation.</li> </ol>"},{"location":"smells/008-singular-plural-logic-clones/#step-implementation","title":"Step Implementation","text":"JavaPythonC#Go CustomerStepDefinitions.java<pre><code>@Given(\"there is a customer\")  // (1)!\npublic void thereIsACustomer(DataTable customerTable) {\n    List&lt;List&lt;String&gt;&gt; row = customerTable.asLists(String.class);\n\n    customerService.addCustomer(row.get(0).get(0), row.get(0).get(1), DEFAULT_BIRTHDAY);\n}\n\n@Given(\"there are some customers\")\npublic void thereAreSomeCustomers(DataTable customerTable) {\n    List&lt;Map&lt;String, String&gt;&gt; rows = customerTable.asMaps(String.class, String.class);\n    for (Map&lt;String, String&gt; col : rows) {\n        customerService.addCustomer(col.get(\"firstname\"), col.get(\"lastname\"), DEFAULT_BIRTHDAY);\n    }\n}\n</code></pre> <ol> <li>The expressions <code>there is a customer</code> and <code>there are some customers</code> handle the singular and plural case of the same step. The share a similar logic and can therefore be merged.</li> </ol> features/steps/steps.py<pre><code>@given(u'there is a customer') # (1)!\ndef step_impl(context):\n        table = context.table\n        context.service.add_customer(table.headings[0], table.headings[1], context.default_birthday)\n\n@given(u'there are some customers')\ndef step_impl(context):\n    for row in context.table.rows:\n        context.service.add_customer(row[\"firstname\"], row[\"lastname\"], context.default_birthday)\n</code></pre> <ol> <li>The expressions <code>there is a customer</code> and <code>there are some customers</code> handle the singular and plural case of the same step. The share a similar logic and can therefore be merged.</li> </ol> CustomerStepDefinitions.cs<pre><code>[Given(\"there is a customer\")] // (1)!\npublic void GivenThereIsACustomer(Table customerTable)\n{\n    var customer = customerTable.Header.ToArray();\n    _customerService.AddCustomer(customer[0], customer[1], DefaultBirthday);\n}\n\n[Given(\"there are some customers\")]\npublic void GivenThereAreSomeCustomers(Table customerTable)\n{\n    var customers = customerTable.CreateSet&lt;CustomerData&gt;(() =&gt; new CustomerData(\"John\", \"Doe\", DefaultBirthday));\n    foreach (var customer in customers)\n    {\n        _customerService.AddCustomer(customer.FirstName, customer.LastName, customer.Birthday);\n    }\n}\n</code></pre> <ol> <li>The expressions <code>there is a customer</code> and <code>there are some customers</code> handle the singular and plural case of the same step. The share a similar logic and can therefore be merged.</li> </ol> customer_test.go<pre><code>func InitializeScenario(sc *godog.ScenarioContext) {\n    // ...\n    // (1)!\n    sc.Given(`there is a customer`, t.thereIsACustomer)\n    sc.Given(`there are some customers`, t.thereAreSomeCustomers)\n    // ...\n}\n\nfunc (t *CustomerTestSteps) thereIsACustomer(ctx context.Context, table *godog.Table) error {\n    row := table.Rows[0]\n    t.customerService.AddCustomer(row.Cells[0].Value, row.Cells[1].Value, DEFAULT_BIRTHDAY)\n    return nil\n}\n\nfunc (t *CustomerTestSteps) thereAreSomeCustomers(ctx context.Context, table *godog.Table) error {\n    for i, row := range table.Rows {\n        if i == 0 {\n            continue // skip header...\n        }\n        t.customerService.AddCustomer(row.Cells[0].Value, row.Cells[1].Value, DEFAULT_BIRTHDAY)\n    }\n    return nil\n}\n</code></pre> <ol> <li>The functions <code>thereIsACustomer</code> and <code>thereAreSomeCustomers</code> handle the singular and plural case of the same step. The share a similar logic and can therefore be merged.</li> </ol>"},{"location":"smells/009-dead-steps/","title":"009: Dead Steps","text":"<p>\u201cDead Steps\u201d refer to step implementations that exist within your codebase but are not used by any feature file. These steps may have been created for various reasons (e.g., experimentation, incomplete scenarios, or refactoring) but are now obsolete. Detecting and removing them can be challenging because they don\u2019t contribute to any scenario.</p>"},{"location":"smells/009-dead-steps/#impact","title":"Impact","text":"<p>Harder Maintenance</p> <p>Dead steps clutter your test codebase, making it harder to maintain.</p> <p>Cusing Confision</p> <p>Developers and testers may wonder why certain steps exist without corresponding scenarios.</p> <p>Potential Misuse</p> <p>If someone accidentally uses a dead step, it can lead to false positives or negatives in test results and increas complexity and maintenance efforts later on.</p>"},{"location":"smells/009-dead-steps/#required-action","title":"Required Action","text":"<p>Search for the <code>Dead Steps</code> in the step implementation file. Either use the tools provided in your IDE or the search functionality. If a step is not used, analyse the history or look out for similar steps. A reason for <code>Dead Steps</code> are incomplete refactorings due to renaming expressions or new steps in scenarios instead of reusage. </p> <p>Delete the unused steps from the code and commit your changes. </p> <p>When changing or refactoring scenarios or step implementations periodically review your step definitions and remove unused ones. Use version control history to identify steps that were once relevant but are no longer needed.</p>"},{"location":"smells/009-dead-steps/#code-examples","title":"Code Examples","text":"<p>These code examples are a bit harder to show as we are looking for some steps that are defined in the implementation that are never used within the Gherkin feature files. There are some telltale signs, such as missing functionality in the step definition code that can point to such smells though.</p> JavaPythonC#Go CustomerStepDefinitions.java<pre><code>@Given(\"there are no customers\") // (1)!\npublic void thereAreNoCustomers() {\n}\n\n@Given(\"no customers exist\")\npublic void noCustomersExist() {\n}\n</code></pre> <ol> <li>The steps <code>there are no customers</code> and <code>no customers exist</code> have a similar meaning. You can clearly see that none of them really has any functionality, which may also hint to the Rotten Steps smell. If none of these are used in any of the scenarios they are to be considered <code>dead steps</code>.</li> </ol> features/steps/steps.py<pre><code>@given(\"there are no customers\") # (1)!\ndef step_impl(comtext):\n    pass\n\n@given(\"no customer exists\")\ndef step_impl(comtext):\n    pass\n</code></pre> <ol> <li>The steps <code>there are no customers</code> and <code>no customers exist</code> have a similar meaning. You can clearly see that none of them really has any functionality, which may also hint to the Rotten Steps smell. If none of these are used in any of the scenarios they are to be considered <code>dead steps</code>.</li> </ol> CustomerStepDefinitions.cs<pre><code>[Given(\"there are no customers\")] // (1)!\npublic void GivenThereAreNoCustomers()\n{\n}\n\n[Given(\"are no customers\")]\npublic void GivenNoCustomersExists()\n{\n}\n</code></pre> <ol> <li>The steps <code>there are no customers</code> and <code>no customers exist</code> have a similar meaning. You can clearly see that none of them really has any functionality, which may also hint to the Rotten Steps smell. If none of these are used in any of the scenarios they are to be considered <code>dead steps</code>.</li> </ol> customer_test.go<pre><code>func InitializeScenario(sc *godog.ScenarioContext) {\n    // ...\n    sc.Given(`there are no customers`, t.thereAreNoCustomers)       // (1)!\n    sc.Given(`no customers exist`, t.noCustomersExist)\n    // ...\n}\n\n\nfunc (t *CustomerTestSteps) thereAreNoCustomers(ctx context.Context) error {\n    return nil\n}\n\nfunc (t *CustomerTestSteps) noCustomersExist(ctx context.Context) error {\n    return nil\n}\n</code></pre> <ol> <li>The steps <code>there are no customers</code> and <code>no customers exist</code> have a similar meaning. You can clearly see that none of them really has any functionality, which may also hint to the Rotten Steps smell. If none of these are used in any of the scenarios they are to be considered <code>dead steps</code>.</li> </ol>"},{"location":"smells/010-hardcoded-parameters/","title":"010: Hardcoded Parameters","text":"<p>\u201cHardcoded Parameters\u201d occur when Gherkin scenarios use fixed, literal values instead of parameters or placeholders. Instead of leveraging reusable parameters, steps directly reference specific values. This leads to redundancy, as multiple steps end up performing the same action with hardcoded data.</p>"},{"location":"smells/010-hardcoded-parameters/#impact","title":"Impact","text":"<p>Harder Maintenance</p> <p>Steps with identical hardcoded values create unnecessary repetition. If a value changes, you must update it in multiple places.</p> <p>Unreadable Code</p> <p>Non parameterized steps reduce the scenario readability. Parameterization allows flexibility and reusability.</p>"},{"location":"smells/010-hardcoded-parameters/#required-action","title":"Required Action","text":"<p>Check your code for step definitions that use data that could be exchanged with other data (e.g. names, dates, quantities, ...) but are not parametrized within the step implementation code. </p> <p>When introducing new steps or refactoring existing steps make sure that you are parametrizing potentially exchangeable parts of the step that are actually data. For example in the step </p> <pre><code>Given there is a user born on 1970-01-01\n</code></pre> <p>the date of <code>1970-01-01</code> should be a parameter in the step definition and not hardcoded.</p> <ul> <li>Leverage Parameter Handling: Implement a new step with placeholders and parameters for dynamic values. Replace all hardcoded steps with the new step and remove the previous step implementations.</li> <li>Ensure Consistent Syntax: Standardize the parameter handling syntax across all step definitions to improve readability and maintainability.</li> <li>Reuse Existing Steps: If a parameterized version exists, ensure consistent usage.</li> <li>Avoid Duplication in Scenarios: Merge similar scenarios to a data driven test ('Scenario Outline' in Gherkin) and provide mulitple examples in tables.</li> </ul>"},{"location":"smells/010-hardcoded-parameters/#code-examples","title":"Code Examples","text":"JavaPythonC#Go CustomerStepDefinitions.java<pre><code>@When(\"the customer Sabine Mustermann is searched\") // (1)!\npublic void theCustomerSabineMustermannIsSearched()\n{\n    _count = _customerService.FindCustomers(\"Sabine\", \"Mustermann\").Count;\n}\n</code></pre> <ol> <li>In the step definition the name <code>Sabine Mustermann</code> is hard coded. It should be a parameter instead that can be changed to e.g. <code>Rose Smith</code> to avoid duplicates for the same functionality but slightly different scenarios.</li> </ol> features/steps/steps.py<pre><code>@when(u'the customer Sabine Mustermann is searched') # (1)!\ndef step_impl(context):\n   context.count = len(context.service.search_customers(\"Sabine\", \"Mustermann\"))   \n</code></pre> <ol> <li>In the step definition the name <code>Sabine Mustermann</code> is hard coded. It should be a parameter instead that can be changed to e.g. <code>Rose Smith</code> to avoid duplicates for the same functionality but slightly different scenarios.</li> </ol> CustomerStepDefinitions.cs<pre><code>[When(\"the customer Sabine Mustermann is searched\")] // (1)!\npublic void WhenTheCustomerSabineMustermannIsSearched()\n{\n    _count = _customerService.FindCustomers(\"Sabine\", \"Mustermann\").Count;\n}\n</code></pre> <ol> <li>In the step definition the name <code>Sabine Mustermann</code> is hard coded. It should be a parameter instead that can be changed to e.g. <code>Rose Smith</code> to avoid duplicates for the same functionality but slightly different scenarios.</li> </ol> customer_test.go<pre><code>func InitializeScenario(sc *godog.ScenarioContext) {\n    // ...\n    sc.When(`the customer Sabine Mustermann is searched`, t.theCustomerSabineMustermannIsSearched)\n    // ...\n}\n\n// (1)!\nfunc (t *CustomerTestSteps) theCustomerSabineMustermannIsSearched(ctx context.Context) error {\n   t.count = len(t.customerService.SearchCustomersByName(\"Sabine\", \"Mustermann\"))\n   return nil\n}\n</code></pre> <ol> <li>In the step definition the name <code>Sabine Mustermann</code> is hard coded. It should be a parameter instead that can be changed to e.g. <code>Rose Smith</code> to avoid duplicates for the same functionality but slightly different scenarios.</li> </ol>"},{"location":"smells/011-active-sideeffects-in-then-step/","title":"011: Active Side Effects in Then Step","text":"<p>The Active Side Effects in Then Step occurs when a <code>Then</code> step, which should be used exclusively for verifying outcomes, is incorrectly used to perform actions that modify the application's internal state, such as creating or altering data.</p> <p>This is a case of misaligned purpose, where operations meant for </p> <ul> <li><code>Given</code> (for setup) or </li> <li><code>When</code> (for executing actions) </li> </ul> <p>steps are mistakenly placed in the <code>Then</code> step. The <code>Then</code> step is intended solely for assertions and validation, ensuring that the application behaves as expected based on the actions performed.</p> <p>Introducing state changes in this step confuses the purpose of the test and can lead to unreliable or misleading results.</p>"},{"location":"smells/011-active-sideeffects-in-then-step/#impact","title":"Impact","text":"<p>Unreadable Code</p> <p>The scenario becomes harder to read and understand because the distinction between setting up, acting, and verifying is blurred. This can make it difficult to discern the intent behind each step and what is being tested.</p> <p>Harder Maintenance</p> <p>Tests that include state changes in <code>Then</code> steps are more difficult to maintain. Since <code>Then</code> steps are expected to be idempotent (i.e., not change the system's state), including state-altering actions here can lead to fragile tests that are sensitive to changes in the application's logic or structure.</p> <p>Harder Analysis</p> <p>Mixing state changes with assertions in <code>Then</code> steps diminishes the clarity of the test, making it unclear what the expected outcome is supposed to validate, as action and validation are confused. This makes it harder to analyse when your scenarios are failing. </p> <p>Increased Complexity</p> <p>Introducing side effects in <code>Then</code> steps lead to tighter coupling between tests and the underlying code, increasing the complexity and interdependencies between steps. This makes the test suite more brittle and less modular. Further you might need to consider cleanup procedures even though you would expect it here.</p>"},{"location":"smells/011-active-sideeffects-in-then-step/#required-actions","title":"Required Actions","text":""},{"location":"smells/011-active-sideeffects-in-then-step/#fixing","title":"Fixing","text":"<ul> <li>Separate Concerns: Ensure that any action that changes the state of the application is placed in the appropriate <code>Given</code> or <code>When</code> step. Given should handle all setup and preconditions, while When should execute the actions that the scenario is testing.</li> <li>Use Background Steps: Utilize the <code>Background</code> section to set up common data or preconditions shared across multiple scenarios. Keep the <code>Then</code> step focused on verifying outcomes without introducing side effects.</li> </ul> <p>Remember that adhering to the intended purpose of each step (<code>Given</code>, <code>When</code>, <code>Then</code>) promotes cleaner, more maintainable Gherkin scenarios and reduces the risk of introducing Cucumber diseases like this one.</p>"},{"location":"smells/011-active-sideeffects-in-then-step/#prevention","title":"Prevention","text":"<ul> <li>Refactor the Then Steps: If you find state-altering code within a <code>Then</code> step, refactor it by moving those actions to a Given or When step, depending on where it logically belongs. <code>Then</code> steps should be refocused on assertions that check the results of actions performed in the When step.</li> <li>Review Scenarios for Alignment: Regularly review your scenarios to ensure that each step is aligned with its intended purpose. <code>Given</code> sets up the context, When performs the actions, and <code>Then</code> verifies the outcomes. This alignment helps maintain clear and understandable tests.</li> <li>Use Mocks or Stubs: If the <code>Then</code> step is intended to validate interactions without causing side effects, consider using mocks or stubs. This approach allows you to simulate the interaction without actually changing the application's state, keeping your <code>Then</code> steps focused on validation.</li> </ul>"},{"location":"smells/011-active-sideeffects-in-then-step/#code-examples","title":"Code Examples","text":"JavaPythonC#Go CustomerStepDefinitions.java<pre><code>@Then(\"the second customer can be found\")\npublic void theSecondCustomerCanBeFound() {\n    customerService.addCustomer(secondFirstName, secondLastName, DEFAULT_BIRTHDAY); // (1)!\n    var customer = customerService.searchCustomer(secondFirstName, secondLastName);\n\n    Assertions.assertThat(customer.firstName).isEqualTo(secondFirstName);\n    Assertions.assertThat(customer.lastName).isEqualTo(secondLastName);\n}\n</code></pre> <ol> <li>Creating the customer in the <code>Then</code> step is an active side effect. Since we are checking exactly this data, we should move it to a appropiate <code>When</code> impelementation. </li> </ol> features/steps/steps.py<pre><code>@then(u'the creation of customer (?P&lt;first_name&gt;.*?) (?P&lt;last_name&gt;.*?) should fail')\ndef step_impl(context, first_name, last_name):\n    caught = None\n    try:\n        # (1)!\n        context.service.add_customer(first_name, last_name, context.default_birthday) \n    except ValueError as e:\n        caught = e\n\n    assert_that(caught).is_not_none()\n    assert_that(str(caught)).is_equal_to(\"Customer already exists\")\n</code></pre> <ol> <li>Creating the customer in the <code>Then</code> step is an active side effect. Since we are checking exactly this data, we should move it to a appropiate <code>When</code> impelementation. </li> </ol> CustomerStepDefinitions.cs<pre><code>[Then(\"the second customer can be found\")]\npublic void ThenTheSecondCustomerCanBeFound()\n{\n    _customerService.AddCustomer(_secondFirstName, _secondLastName, DefaultBirthday); // (1)!\n    var customer = _customerService.FindCustomer(_secondFirstName, _secondLastName);\n\n    customer.Should().BeEquivalentTo(new { FirstName = _secondFirstName, LastName = _secondLastName });\n}\n</code></pre> <ol> <li>Creating the customer in the <code>Then</code> step is an active side effect. Since we are checking exactly this data, we should move it to a appropiate <code>When</code> impelementation. </li> </ol> customer_test.go<pre><code>func InitializeScenario(sc *godog.ScenarioContext) {\n    // ...\n    sc.Then(`the second customer creation should fail`, t.theSecondCustomerCreationShouldFail)\n    // ...\n}\n\nfunc (t *CustomerTestSteps) theSecondCustomerCreationShouldFail(ctx context.Context) error {\n    // (1)!\n    err := t.customerService.AddCustomer(t.secondFirstName, t.secondLastName, DEFAULT_BIRTHDAY)\n    if err == nil {\n        return fmt.Errorf(\"expected error but got nil\")\n    }\n\n    if err.Error() != \"customer already exists\" {\n        return fmt.Errorf(\"expected 'customer already exists' error but got '%s'\", err.Error())\n    }\n\n    return nil\n}\n</code></pre> <ol> <li>Creating the customer in the <code>Then</code> step is an active side effect. Since we are checking exactly this data, we should move it to a appropiate <code>When</code> impelementation. </li> </ol>"},{"location":"smells/012-dependence-on-class-state/","title":"012: Dependence on Class State","text":"<p>The \"Dependence on Class State\" occurs when step definitions rely heavily on class fields or context objects to store and share data between steps. Often, this state is duplicated or overlaps with previously prepared data in the application, leading to unnecessary complexity. In this scenario, the state is stored either in the fields of the step definition class or in a shared context object, which is akin to a global variable. This approach introduces hidden dependencies between steps and can result in tightly coupled tests where the behavior of one step is implicitly tied to the internal state managed by the class or context. This creates a brittle test structure where understanding and maintaining the state becomes challenging, especially as the test suite grows.</p>"},{"location":"smells/012-dependence-on-class-state/#impact","title":"Impact","text":"<p>Unreadable Code</p> <p>Tests become harder to understand as the state of the application is scattered across multiple locations.</p> <p>Harder Maintenance</p> <p>Storing state in class fields or context introduces tight coupling between steps. As tests evolve, changing the state management in one step could inadvertently break others, leading to fragile and harder-to-maintain test cases.</p> <p>Increased Complexity</p> <p>Sharing state always increases complexity, as developers need to understand not only the logic of each step but also how the state is manipulated across multiple steps. This makes the tests more prone to errors and bugs, especially in large test suites.</p> <p>Increased Coupling</p> <p>Using context or class fields to manage state creates implicit dependencies between steps, violating the principle of isolation between tests. This can lead to flakiness, where tests might pass or fail depending on the order in which they are executed.</p>"},{"location":"smells/012-dependence-on-class-state/#required-action","title":"Required Action","text":""},{"location":"smells/012-dependence-on-class-state/#fixing","title":"Fixing","text":"<ul> <li>Pass Data Explicitly: Instead of relying on fields in the step implementation class, refactor your steps and pass data directly between steps via method parameters or use clear, explicit constructs like local variables. This keeps the state management simple, localized, and easy to follow.</li> <li>Refactor Tests to Reduce Duplication: Ensure that state is only prepared once in the Given step, avoiding the need for duplicated or redundant state management. Ensure each step has a clear and distinct responsibility, and refactor any steps that introduce unnecessary coupling or complexity through shared state.</li> <li>Use Scenario Context Sparingly: Context objects can act like global variables, leading to unclear and tightly coupled tests, avoid overusing it. Limit the amount of data stored in the context to essential information. Consider whether a step really needs access to the entire context or if a smaller subset suffices.</li> <li>Replace static objects with context objects: Never use static shared objects to exchange state between steps. If you must share state across steps, dependency injection of context objects to manage it in a controlled and transparent way. This allows for better control over the lifecycle and visibility of shared state.</li> </ul>"},{"location":"smells/012-dependence-on-class-state/#prevention","title":"Prevention","text":"<ul> <li>Reuse Application State: Don't hold data twice in your application and in your test classes. Prefer the usage of test data in your application state for example a database instead of temporary storage in your objects.</li> <li>Keep Steps Isolated: Steps should not depend on state manipulated by previous steps. Each step should be able to stand alone and express its purpose clearly. If state sharing is necessary, consider refactoring the test logic to make the dependencies explicit and well-defined.</li> <li>Avoid Premature Data Gathering: Gather data only when needed. If data can be collected later in the scenario, defer its retrieval to a later step and pass it to the subsequent steps as necessary.</li> </ul>"},{"location":"smells/012-dependence-on-class-state/#code-examples","title":"Code Examples","text":""},{"location":"smells/012-dependence-on-class-state/#step-implementation","title":"Step Implementation","text":"JavaPythonC#Go CustomerStepDefinitions.java<pre><code>private String firstName; // (1)!\nprivate String lastName;\n\n@Given(\"the customer name is {} {}\")\npublic void theCustomerNameIs(String firstName, String lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n\n@When(\"the customer is created\")\n@When(\"an invalid customer is created\")\npublic void createCustomerAndStoreSuccess() {\n    try {\n        customerService.addCustomer(firstName, lastName, DEFAULT_BIRTHDAY);\n    } catch (IllegalArgumentException e) {\n        error = e;\n    }\n}\n\n@Then(\"the customer can be found\")\npublic void theCustomerCanBeFound() {\n    var customer = customerService.searchCustomer(firstName, lastName);\n    Assertions.assertThat(customer).isNotNull();\n}\n</code></pre> <ol> <li>The fields <code>firstName</code> and <code>lastName</code> are populuted over all steps. Consider passing them as parameters. This makes the steps independent and reusable for other fields, too.</li> </ol> features/steps/steps.py<pre><code>...\n</code></pre> <ol> <li>The expressions <code>there is a customer</code> and <code>there are some customers</code> handle the singular and plural case of the same step. The share a similar logic and can therefore be merged.</li> </ol> CustomerStepDefinitions.cs<pre><code>private string _firstName; // (1)!\nprivate string _lastName;\n\n[Given(\"the customer name is {} {}\")]\npublic void GivenTheCustomerNameIs(string firstName, string lastName)\n{\n    _firstName = firstName;\n    _lastName = lastName;\n}\n\n[When(\"the customer is created\")]\n[When(\"an invalid customer is created\")]\npublic void CreateCustomerAndStoreSuccess()\n{\n    try\n    {\n        _customerService.AddCustomer(_firstName, _lastName, DefaultBirthday);\n    }\n    catch (ArgumentException ex)\n    {\n        _error = ex;\n    }\n}\n\n[Then(\"the customer can be found\")]\npublic void ThenTheCustomerCanBeFound()\n{\n    var customer = _customerService.FindCustomer(_firstName, _lastName);\n    customer.Should().BeEquivalentTo(new { FirstName = _firstName, LastName = _lastName });\n}\n</code></pre> <ol> <li>The fields <code>firstName</code> and <code>lastName</code> are populuted over all steps. Consider passing them as parameters. This makes the steps independent and reusable for other fields, too.</li> </ol> customer_test.go<pre><code>...\n</code></pre> <ol> <li>The functions <code>thereIsACustomer</code> and <code>thereAreSomeCustomers</code> handle the singular and plural case of the same step. The share a similar logic and can therefore be merged.</li> </ol>"},{"location":"smells/013-test-code-impurity/","title":"013: Test Code Impurity","text":"<p>\u201cTest Code Impurity\u201d arises when step definitions contain complex business logic that goes beyond their primary purpose\u2014acting as a bridge between human-readable scenarios and underlying automation code. Instead of keeping step definitions simple, they become heavily tied to the details of the system under test (SUT). This impurity in test code results in a step definition that becomes too verbose (often exceeding 10 lines) and overly reliant on the system\u2019s inner workings, which increases the risk of tight coupling. As a result, the tests are less adaptable to changes in the SUT and require significant effort to modify and update.</p>"},{"location":"smells/013-test-code-impurity/#impact","title":"Impact","text":"<p>Unreadable Code</p> <p>When business logic is mixed with test code, it becomes harder to understand the purpose of each step. Developers may struggle to differentiate between actual test steps and implementation details.</p> <p>Harder Maintenance</p> <p>When business logic is embedded in step definitions, even small changes in the SUT can require extensive rework of the test automation. This increases the effort needed to maintain the tests over time, especially in complex or large-scale projects.</p> <p>Increased Coupling</p> <p>The business logic embedded within step definitions creates a strong dependency between the test code and the SUT. Any changes to the business rules or system behavior can propagate throughout the entire test suite, leading to maintenance difficulties.</p> <p>Missing Scalability</p> <p>Complex step definitions hinder scalability. As the number of scenarios grows, managing intertwined business logic becomes unwieldy as they are tightly coupled to the system's implementation..</p> <p>Limited Reusability</p> <p>Heavily logic-driven step definitions are often too specific, making it difficult to reuse them across different scenarios.</p> <p>The tight coupling introduced by this code smell makes the test suite challenging to maintain and less adaptable to changes in the SUT.</p>"},{"location":"smells/013-test-code-impurity/#required-action","title":"Required Action","text":"<ul> <li> <p>Keep Step Definitions Simple: Step definitions should act as a thin layer between Gherkin scenarios and automation code. They should be concise, typically no longer than 10 lines, and focus only on calling methods that implement the behavior being tested. Avoid putting complex business logic directly in step definitions.</p> </li> <li> <p>Use a Design with different Test Automation Layers: Seperate different concerns of the test automation code into different levels for example a business rule, workflow and technical level. Introduce pattern like Page Objects, Drivers and Helper Classes and extract the code according to your selected test automation architecture. This separation of concerns ensures that the test automation code remains modular and easy to maintain. Step definitions should focus solely on describing what action is being performed, not how it is implemented.</p> </li> <li> <p>Extract Helper Classes: If a test action requires complex logic, encapsulate that logic in a well-named method in a helper class. This keeps the step definition readable while still achieving the necessary functionality.</p> </li> <li> <p>Use Builders or Factories for Complex Test Data: For scenarios requiring complex test data, avoid constructing objects directly within the step definitions. Instead, use builder patterns or factory classes to encapsulate the creation of test data. This keeps the step definitions clean, while the builder or factory handles the complexity of constructing objects with various configurations. This approach also encourages reusability and reduces duplication in your test data setup.</p> </li> </ul>"},{"location":"smells/013-test-code-impurity/#code-examples","title":"Code Examples","text":""},{"location":"smells/013-test-code-impurity/#step-implementation","title":"Step Implementation","text":"JavaPythonC#Go CustomerStepDefinitions.java<pre><code>...\n</code></pre> <ol> <li>The expressions <code>there is a customer</code> and <code>there are some customers</code> handle the singular and plural case of the same step. The share a similar logic and can therefore be merged.</li> </ol> features/steps/steps.py<pre><code>...\n</code></pre> <ol> <li>The expressions <code>there is a customer</code> and <code>there are some customers</code> handle the singular and plural case of the same step. The share a similar logic and can therefore be merged.</li> </ol> CucumberDiseases.Specs/StepDefinitions/CustomerStepDefinitions.cs<pre><code>...\n</code></pre> <ol> <li>The expressions <code>there is a customer</code> and <code>there are some customers</code> handle the singular and plural case of the same step. The share a similar logic and can therefore be merged.</li> </ol> customer_test.go<pre><code>...\n</code></pre> <ol> <li>The functions <code>thereIsACustomer</code> and <code>thereAreSomeCustomers</code> handle the singular and plural case of the same step. The share a similar logic and can therefore be merged.</li> </ol>"}]}